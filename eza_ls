#!/bin/bash
# eza_ls - A wrapper script that makes eza behave like ls (BSD and GNU compatible)

args=("$@")
eza_args=()
file_args=()
has_reverse=0
has_sort=0
sort_type="none"
has_human_readable=0
has_group=0
print_only=0
arg_index=0
has_file_arg=0
needs_long=0
unsupported_flags=()

scan_arg() {
    local arg="$1"
    case "$arg" in
        -S|-t|-X)
            has_sort=1
            has_reverse=1
            ;;
        --sort=*)
            has_sort=1
            has_reverse=1
            ;;
        -f)
            has_sort=1
            ;;
        -h|--human-readable)
            has_human_readable=1
            ;;
        -G|--no-group)
            has_group=1
            ;;
        -g|-o)
            has_group=1
            ;;
        --eza)
            print_only=1
            ;;
        -b|-I|-w|--block-size|-D)
            ((arg_index++))
            ;;
    esac
}

arg_index=0
seen_ddash=0
while [[ $arg_index -lt ${#args[@]} ]]; do
    arg="${args[$arg_index]}"

    if [[ "$arg" == "--" ]]; then
        seen_ddash=1
        ((arg_index++))
        continue
    fi

    if [[ $seen_ddash -eq 0 && "$arg" == -* && "${#arg}" -gt 2 && "$arg" != "--"* ]]; then
        prefix="${arg:0:2}"
        rest="${arg:2}"
        scan_arg "$prefix"
        for ((i=0; i<${#rest}; i++)); do
            scan_arg "-${rest:$i:1}"
        done
    elif [[ $seen_ddash -eq 0 ]]; then
        scan_arg "$arg"
    fi

    ((arg_index++))
done

process_arg() {
    local arg="$1"
    local consume_next="${2:-0}"

    if [[ $consume_next -eq 1 ]]; then
        ((arg_index++))
        local next_arg="${args[$arg_index]}"
        case "$arg" in
            --block-size)
                case "$next_arg" in
                    K) eza_args+=("--binary") ;;
                    B) eza_args+=("--bytes") ;;
                    *) eza_args+=("--binary") ;;
                esac
                return
                ;;
            -I|--ignore)
                eza_args+=("--ignore-glob=$next_arg")
                return
                ;;
            -w|--width)
                eza_args+=("--width=$next_arg")
                return
                ;;
            -D)
                eza_args+=("--time-style=+$next_arg")
                return
                ;;
        esac
    fi

    case "$arg" in
        # BSD/GNU: extended attributes
        -@)
            eza_args+=("--extended")
            ;;
        # BSD/GNU: one per line
        -1)
            eza_args+=("--oneline")
            ;;
        # BSD/GNU: show hidden files + . and ..
        -a|--all)
            eza_args+=("--all" "--all")
            ;;
        # BSD/GNU: show hidden files (no . or ..)
        -A)
            eza_args+=("--almost-all")
            ;;
        # GNU: author (unsupported)
        --author)
            unsupported_flags+=("$arg")
            ;;
        # unsupported: escape non-printable
        -b)
            ;;
        # BSD/GNU: block size
        --block-size=*)
            size="${arg#*=}"
            case "$size" in
                K) eza_args+=("--binary") ;;
                B) eza_args+=("--bytes") ;;
                *) eza_args+=("--binary") ;;
            esac
            ;;
        # BSD/GNU: block size
        --block-size)
            process_arg "$arg" 1
            ;;
        # GNU: ignore backups (~)
        -B)
            eza_args+=("--ignore-glob=*~")
            ;;
        # BSD/GNU: ctime
        -c)
            eza_args+=("--time=changed" "--time-style=long-iso")
            ;;
        # BSD/GNU: columns
        -C)
            eza_args+=("--grid")
            ;;
        # BSD/GNU: list dirs as files
        -d|--directory)
            eza_args+=("--treat-dirs-as-files")
            ;;
        # BSD: custom date format
        -D)
            process_arg "$arg" 1
            ;;
        # BSD: print ACL (unsupported)
        -e)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: no sort, show all
        -f)
            eza_args+=("--all")
            eza_args+=("--all")
            sort_type="none"
            ;;
        # BSD/GNU: classify
        -F|--classify)
            if [[ "$arg" == *=* ]]; then
                eza_args+=("--classify=${arg#*=}")
            else
                eza_args+=("--classify=auto")
            fi
            ;;
        # GNU: no group
        -G)
            ;;
        # BSD/GNU: no group
        -G|--no-group)
            ;;
        # BSD/GNU: human readable (handled specially)
        -h|--human-readable)
            ;;
        # BSD/GNU: follow symlinks on command line
        -H)
            eza_args+=("--links")
            ;;
        # BSD/GNU: inode
        -i|--inode)
            eza_args+=("--inode")
            ;;
        # BSD/GNU: ignore pattern
        -I|--ignore)
            if [[ "$arg" == *=* ]]; then
                eza_args+=("--ignore-glob=${arg#*=}")
            else
                process_arg "$arg" 1
            fi
            ;;
        # BSD/GNU: kibibytes
        -k)
            eza_args+=("--binary")
            ;;
        # BSD/GNU: long format
        -l)
            needs_long=1
            ;;
        # BSD/GNU: dereference
        -L|--dereference)
            eza_args+=("--dereference")
            ;;
        # BSD/GNU: modified time
        -m)
            eza_args+=("--modified")
            ;;
        # BSD/GNU: numeric uid/gid
        -n|--numeric-uid-gid)
            eza_args+=("--numeric")
            ;;
        # BSD: file flags (unsupported)
        -O)
            unsupported_flags+=("$arg")
            ;;
        # GNU: long without owner
        -g)
            needs_long=1
            eza_args+=("--no-user")
            eza_args+=("--group")
            has_group=1
            ;;
        # GNU: long without group
        -o)
            needs_long=1
            has_group=1
            ;;
        # BSD: don't follow symlinks (unsupported)
        -P)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: classify directories
        -p)
            eza_args+=("--classify=auto")
            ;;
        # BSD/GNU: hide control chars (unsupported)
        -q|--hide-control-chars)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: reverse
        -r|--reverse)
            (( has_reverse = !has_reverse ))
            ;;
        # BSD/GNU: recursive
        -R|--recursive)
            eza_args+=("--recurse")
            ;;
        # BSD/GNU: size
        -s|--size)
            eza_args+=("--blocksize")
            ;;
        # GNU: SI units (unsupported)
        --si)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: sort by size
        -S)
            sort_type="size"
            ;;
        # BSD/GNU: sort by time
        -t)
            sort_type="modified"
            ;;
        # BSD: full timestamp
        -T)
            eza_args+=("--time-style=full-iso")
            ;;
        # BSD/GNU: tab size (unsupported)
        --tab-size=*)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: accessed time
        -u)
            eza_args+=("--accessed")
            ;;
        # BSD: use created time
        -U)
            eza_args+=("--created")
            ;;
        # BSD/GNU: version
        -v|--version)
            eza_args+=("--version")
            ;;
        # BSD: display whiteouts (unsupported)
        -W)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: width
        -w|--width)
            if [[ "$arg" == *=* ]]; then
                eza_args+=("--width=${arg#*=}")
            else
                process_arg "$arg" 1
            fi
            ;;
        # BSD/GNU: sort across
        -x)
            eza_args+=("--across")
            ;;
        # GNU: sort by extension
        -X|--sort=extension)
            sort_type="extension"
            ;;
        # BSD/GNU: context
        -Z|--context)
            eza_args+=("--context")
            ;;
        # BSD/GNU: color
        --color=*)
            color="${arg#*=}"
            case "$color" in
                always) eza_args+=("--colour=always") ;;
                auto) eza_args+=("--colour=auto") ;;
                never) eza_args+=("--colour=never") ;;
            esac
            ;;
        # BSD/GNU: dereference
        --dereference)
            eza_args+=("--dereference")
            ;;
        # GNU: emacs dired (unsupported)
        --dired)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: file type
        --file-type)
            eza_args+=("--classify=never")
            ;;
        # BSD/GNU: full time
        --full-time)
            needs_long=1
            eza_args+=("--time-style=full-iso")
            ;;
        # BSD/GNU: group directories first
        --group-directories-first)
            eza_args+=("--group-directories-first")
            ;;
        # BSD/GNU: group directories last
        --group-directories-last)
            eza_args+=("--group-directories-last")
            ;;
        # BSD/GNU: hide pattern
        --hide=*)
            eza_args+=("--ignore-glob=${arg#*=}")
            ;;
        # BSD/GNU: hyperlink
        --hyperlink*)
            eza_args+=("--hyperlink")
            ;;
        # BSD/GNU: indicator style
        --indicator-style=*)
            style="${arg#*=}"
            case "$style" in
                none)
                    unsupported_flags+=("$arg")
                    ;;
                file-type) eza_args+=("--classify=never") ;;
                classify) eza_args+=("--classify=always") ;;
                slash) eza_args+=("--classify=auto") ;;
            esac
            ;;
        # GNU: quoting style (unsupported)
        --quoting-style=*)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: literal
        -N|--literal)
            eza_args+=("--no-quotes")
            ;;
        # GNU: quote name (unsupported)
        -Q|--quote-name)
            unsupported_flags+=("$arg")
            ;;
        # BSD/GNU: show all
        --show-all)
            eza_args+=("--all")
            ;;
        # BSD/GNU: sort
        --sort=*)
            sort_field="${arg#*=}"
            case "$sort_field" in
                none) sort_type="none" ;;
                time) sort_type="modified" ;;
                size) sort_type="size" ;;
                extension) sort_type="extension" ;;
                name) sort_type="name" ;;
                version) sort_type="name" ;;
                *) sort_type="$sort_field" ;;
            esac
            ;;
        # BSD/GNU: time field
        --time=*)
            time_field="${arg#*=}"
            case "$time_field" in
                atime|access|use|accessed) eza_args+=("--accessed") ;;
                ctime|status|changed) eza_args+=("--changed") ;;
                birth|creation|created) eza_args+=("--created") ;;
                *) eza_args+=("--time=$time_field") ;;
            esac
            ;;
        # BSD/GNU: time style
        --time-style=*)
            style="${arg#*=}"
            case "$style" in
                full-iso) eza_args+=("--time-style=full-iso") ;;
                long-iso) eza_args+=("--time-style=long-iso") ;;
                iso) eza_args+=("--time-style=iso") ;;
                +*) eza_args+=("--time-style=$style") ;;
                *) eza_args+=("--time-style=$style") ;;
            esac
            ;;
        # Debug: print eza command
        --eza)
            print_only=1
            ;;
        # Separator: pass through
        --)
            ;;
        # Unknown option
        -*)
            unsupported_flags+=("$arg")
            ;;
        # File argument
        *)
            eza_args+=("$arg")
            has_file_arg=1
            ;;
    esac
}

arg_index=0
stop_flag_processing=0
while [[ $arg_index -lt ${#args[@]} ]]; do
    arg="${args[$arg_index]}"

    if [[ "$arg" == "--" ]]; then
        eza_args+=("--")
        stop_flag_processing=1
        ((arg_index++))
        continue
    fi

    if [[ $stop_flag_processing -eq 0 && "$arg" == -* && "${#arg}" -gt 2 && "$arg" != "--"* ]]; then
        prefix="${arg:0:2}"
        rest="${arg:2}"
        process_arg "$prefix"
        for ((i=0; i<${#rest}; i++)); do
            process_arg "-${rest:$i:1}"
        done
    elif [[ $stop_flag_processing -eq 1 ]]; then
        eza_args+=("$arg")
        has_file_arg=1
    else
        process_arg "$arg"
    fi

    ((arg_index++))
done

if (( has_sort )); then
    eza_args+=("--sort=$sort_type")
fi

if (( has_reverse )); then
    eza_args+=("--reverse")
fi

if (( needs_long )); then
    eza_args+=("--long")
fi

if (( !has_file_arg )); then
    eza_args+=(".")
fi

if (( !has_human_readable )); then
    eza_args+=("--bytes")
fi

if (( !has_group )); then
    eza_args+=("-g")
fi

if [[ ${#unsupported_flags[@]} -gt 0 ]]; then
    echo "warning: unsupported option(s): ${unsupported_flags[*]}" >&2
fi

if ((print_only)); then
    echo "eza ${eza_args[*]}"
else
    exec eza "${eza_args[@]}"
fi
